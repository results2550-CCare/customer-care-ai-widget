<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>WOW Cinematic</title>

<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/ShaderPass.js"></script>

<style>
body { margin:0; overflow:hidden; background:#000; }
canvas { display:block; }
</style>
</head>
<body>
<script>

/* ================= BASIC ================= */

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000,20,200);

const camera = new THREE.PerspectiveCamera(
  70,
  window.innerWidth/window.innerHeight,
  0.1,
  2000
);
camera.position.set(0,2,18);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
document.body.appendChild(renderer.domElement);

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

/* ================= LIGHT ================= */

scene.add(new THREE.AmbientLight(0x404040,1.2));

const dir = new THREE.DirectionalLight(0xffffff,1.4);
dir.position.set(10,20,10);
scene.add(dir);

const impactLight = new THREE.PointLight(0x00ffff,0,30);
impactLight.position.set(0,3,-6);
scene.add(impactLight);

/* ================= WALL ================= */

const wall = new THREE.Group();
scene.add(wall);

const shards=[];
const seg=20;
const size=14/seg;

for(let x=-seg/2;x<seg/2;x++){
  for(let y=-seg/2;y<seg/2;y++){
    const shard=new THREE.Mesh(
      new THREE.BoxGeometry(size,size,0.6),
      new THREE.MeshStandardMaterial({color:0x111111,roughness:0.9})
    );
    shard.position.set(x*size,y*size,-6);
    shard.userData={vel:new THREE.Vector3(),broken:false};
    wall.add(shard);
    shards.push(shard);
  }
}

/* ================= ROBOT ================= */

const robot=new THREE.Group();
scene.add(robot);
robot.position.set(0,0,-8);
robot.scale.setScalar(0.01);

const mat=new THREE.MeshStandardMaterial({
  color:0x222222,
  emissive:0x00ffff,
  emissiveIntensity:0.6,
  metalness:1,
  roughness:0.2
});

const core=new THREE.Mesh(
  new THREE.CylinderGeometry(1.5,1.5,2.5,32),
  mat
);
robot.add(core);

const arms=[];
for(let i=0;i<6;i++){
  const pivot=new THREE.Group();
  const arm=new THREE.Mesh(
    new THREE.BoxGeometry(0.4,3,0.4),
    mat
  );
  arm.position.y=2;
  pivot.add(arm);
  pivot.rotation.y=(i/6)*Math.PI*2;
  robot.add(pivot);
  arms.push(pivot);
}

/* ================= SPARKS ================= */

const sparkCount=200;
const sparkGeo=new THREE.BufferGeometry();
const sparkPos=new Float32Array(sparkCount*3);
sparkGeo.setAttribute('position',new THREE.BufferAttribute(sparkPos,3));
const sparkMat=new THREE.PointsMaterial({color:0xffcc00,size:0.15});
const sparks=new THREE.Points(sparkGeo,sparkMat);
sparks.visible=false;
scene.add(sparks);
const sparkVel=[];

/* ================= SHOCK ================= */

const shock=new THREE.Mesh(
  new THREE.RingGeometry(0.5,0.7,64),
  new THREE.MeshBasicMaterial({
    color:0x00ffff,
    side:THREE.DoubleSide,
    transparent:true,
    opacity:0.8
  })
);
shock.rotation.x=Math.PI/2;
shock.position.set(0,0,-5.8);
shock.visible=false;
scene.add(shock);

/* ================= OCEAN ================= */

const oceanGeo=new THREE.PlaneGeometry(400,400,100,100);
const oceanMat=new THREE.MeshStandardMaterial({
  color:0x001f3f,
  wireframe:false
});
const ocean=new THREE.Mesh(oceanGeo,oceanMat);
ocean.rotation.x=-Math.PI/2;
ocean.position.y=-6;
ocean.visible=false;
scene.add(ocean);

/* ================= SATELLITES ================= */

const sats=[];
for(let i=0;i<12;i++){
  const sat=new THREE.Mesh(
    new THREE.SphereGeometry(0.3,16,16),
    new THREE.MeshStandardMaterial({color:0xffffff})
  );
  scene.add(sat);
  sats.push(sat);
}

/* ================= POST FX ================= */

const composer=new THREE.EffectComposer(renderer);
composer.addPass(new THREE.RenderPass(scene,camera));

const CrackShader={
  uniforms:{
    tDiffuse:{value:null},
    impact:{value:new THREE.Vector2(0.5,0.5)},
    time:{value:0},
    strength:{value:0}
  },
  vertexShader:`
    varying vec2 vUv;
    void main(){
      vUv=uv;
      gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
    }
  `,
  fragmentShader:`
    uniform sampler2D tDiffuse;
    uniform vec2 impact;
    uniform float time;
    uniform float strength;
    varying vec2 vUv;

    void main(){
      vec2 uv=vUv;
      float dist=distance(uv,impact);
      float d=strength*0.2/(dist*12.0+0.2);
      uv+=normalize(uv-impact)*d;

      float a=atan(uv.y-impact.y,uv.x-impact.x);
      float cracks=abs(sin(a*20.0+time*2.0));
      cracks*=smoothstep(0.0,0.5,1.0-dist);

      vec2 shift=normalize(uv-impact)*d*0.5;

      vec4 col;
      col.r=texture2D(tDiffuse,uv+shift).r;
      col.g=texture2D(tDiffuse,uv).g;
      col.b=texture2D(tDiffuse,uv-shift).b;
      col.a=1.0;

      col.rgb+=cracks*0.5*strength;
      gl_FragColor=col;
    }
  `
};

const crackPass=new THREE.ShaderPass(CrackShader);
composer.addPass(crackPass);

/* ================= IMPACT ================= */

function impact(){
  robot.scale.setScalar(1);
  robot.position.z=-5.8;
  impactLight.intensity=6;
  shock.visible=true;
  shock.scale.setScalar(0.1);
  shock.material.opacity=1;
  sparks.visible=true;

  for(let i=0;i<sparkCount;i++){
    sparkVel[i]=new THREE.Vector3(
      (Math.random()-0.5)*12,
      Math.random()*12,
      (Math.random()-0.5)*12
    );
  }

  shards.forEach(s=>{
    const d=s.position.distanceTo(robot.position);
    if(d<5){
      s.userData.broken=true;
      s.userData.vel=
        s.position.clone().sub(robot.position)
        .normalize().multiplyScalar(10+Math.random()*5);
    }
  });

  crackPass.uniforms.strength.value=1;
}

/* ================= MORPH ================= */

let morphed=false;

function morphToBird(){
  robot.children.forEach(c=>{
    if(c.geometry) c.geometry.dispose();
  });
  robot.clear();

  const bird=new THREE.Mesh(
    new THREE.ConeGeometry(1.5,4,32),
    new THREE.MeshStandardMaterial({
      color:0xffffff,
      emissive:0x00ffff,
      emissiveIntensity:0.5
    })
  );
  bird.rotation.z=Math.PI;
  robot.add(bird);

  morphed=true;
}

/* ================= LOOP ================= */

const clock=new THREE.Clock();
let hitTime=2;

function animate(){
  requestAnimationFrame(animate);

  const dt=clock.getDelta();
  const t=clock.elapsedTime;

  if(t>hitTime && robot.scale.x<1){
    impact();
  }

  arms.forEach((a,i)=>{
    a.rotation.z=Math.sin(t*3+i)*0.5;
  });

  core.rotation.y+=0.02;

  shards.forEach(s=>{
    if(s.userData.broken){
      s.position.add(s.userData.vel.clone().multiplyScalar(dt));
      s.userData.vel.y-=9.8*dt;
      s.rotation.x+=0.2;
      s.rotation.y+=0.3;
    }
  });

  if(shock.visible){
    shock.scale.multiplyScalar(1.12);
    shock.material.opacity*=0.92;
  }

  if(sparks.visible){
    const pos=sparks.geometry.attributes.position;
    for(let i=0;i<sparkCount;i++){
      pos.array[i*3]+=sparkVel[i].x*dt;
      pos.array[i*3+1]+=sparkVel[i].y*dt;
      pos.array[i*3+2]+=sparkVel[i].z*dt;
      sparkVel[i].y-=9.8*dt;
    }
    pos.needsUpdate=true;
  }

  crackPass.uniforms.time.value+=dt;
  if(crackPass.uniforms.strength.value>0){
    crackPass.uniforms.strength.value*=0.95;
  }

  if(t>5 && !morphed){
    ocean.visible=true;
    morphToBird();
  }

  if(morphed){
    robot.position.y+=dt*4;
    robot.position.z+=dt*6;
  }

  sats.forEach((s,i)=>{
    const angle=t*0.5+i;
    s.position.set(
      Math.cos(angle)*20,
      Math.sin(angle*0.5)*5+10,
      Math.sin(angle)*20
    );
  });

  const verts=ocean.geometry.attributes.position;
  for(let i=0;i<verts.count;i++){
    const x=verts.getX(i);
    const y=verts.getY(i);
    verts.setZ(i,Math.sin(t*2+x*0.1+y*0.1)*0.5);
  }
  verts.needsUpdate=true;

  composer.render();
}

animate();

</script>
</body>
</html>
